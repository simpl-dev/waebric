grammar ee.cyber.waebric.lexer.WaebricSimpl;

scalaheader {
import HelperMethods._
}

Program: 'module' IdCon Definitions Site;

Definitions: Definition+;

Definition: 'def' IdCon '(' arguments=Args ')' 
	statements=Statement*
'end';

RecordPair: pairName=IdCon ":" pairValue=PrimitiveData;
RecordItems: recArg=RecordPair ("," recRest=RecordItems)?;
DataList: "[" list=DataListItems "]";
Args: arg=Expression ("," rst=Args)?;

// primitive
DataNum: numVal=NatCon;
DataSymbol: symVal=SymbolCon;

// with type check as well
DataStr: strVal=Text;
DataRecords: "{" records=RecordItems "}";
DataListItems: listArg=PrimitiveData ("," listRest=DataListItems)?;


Statement: IdCon;

// File Mapping Nodes
Site: 'site' 
	mappings=Mappings+ 
'end';

Mappings: mapping=Mapping ";";
Mapping: path=Path ":" markup=IdCon;	//TODO! Should be Markup not IdCon
Path: (value1=FullPath | value2=FileName);


// Expressions
option PrimitiveData: DataNum | DataStr | DataSymbol;
option Expression: PrimitiveData | DataList | DataRecords;

//Field: Expression "." IdCon;

Field
	returns Expression {FieldExpression(left, field)}
	: left=Expression "." field=IdCon;
Cat 
	returns Expression {makeCat(left :: rest)}
    : left=Expression ("+" rest=Expression)*;


//Predicates
option Predicate: TypeCheck | Not;

TypeCheck returns Predicate {TypeCheckPredicate(exp, t)}: exp=Expression "." t=Types "?";
Not returns Predicate {NotPredicate(p)}: "!" p=Predicate;
Or returns Predicate {getAndOrPredicate(new String("or"), left :: rest)}
    : left=And ("||" rest=And)*;
And returns Predicate {getAndOrPredicate(new String("and"), left :: rest)}
    : left=Predicate ("&&" rest=Predicate)*;

// Types
option Types {
    def text: String
}: TypeList |  TypeString | TypeRecord;


//**** TERMINALS **** //
// Note that the terminals are matched according to the order of definition
// therefore some general terminals are used for multiple places

terminal TypeRecord: 'record';
terminal TypeList: 'list';
terminal TypeString: 'string';

// General
fragment Letter: ('a'..'z'|'A'..'Z');
fragment Digit: ('0'..'9');
fragment Hexadecimal: (Letter | Digit)+;
terminal IdCon: Letter (Letter|Digit|'-')*;
terminal NatCon: Digit+;

// File mapping terminals
fragment PathElement: (Letter|Digit|'%')+; //|~('\\'|'/')
fragment FileExt: (Letter|Digit)+;
terminal FileName: PathElement "." FileExt;
terminal FullPath: ("/")? (PathElement "/")+ FileName;



//Text and TextChar related
fragment TextChar:	~('\u0000'..'\u001F' | '&' | '"' | '<' | '\u0080'..'\uFFFF' ) |
			 '\n' | '\r' | '\t' | EscQuote | Amp | CharRef | EntRef ;
fragment EscQuote:	'\\\\' | '\\"';		
fragment Amp:		'\&' ~('#' | '0'..'9' | 'a'..'z' | 'A'..'Z' | '_' | ':')+;
fragment CharRef:	'&#' Digit+ ';' | '&#x' Hexadecimal ';' ;
fragment EntRef:	'&' ( Letter | '_' | ':' ) ( Letter | Digit | '.' | '-' | '_' | ':')* ';' ;
terminal Text: '\"' TextChar* '\"';


//StrCon and StrChar
//As this will be processed after Text, all patterns that match
//both, were already considered as Text. "comment" tag only
//uses StrCon and this must be considered.
fragment Newline: '\\n';
fragment Tab: '\\t';
fragment Quote: '\\"';
fragment Backslash: '\\\\';
fragment Decimal: '\\\\' 'a:' Digit 'b:' Digit 'c:' Digit;
fragment StrChar: ~('\u0000'..'\u001F' | '"' | '\\') | Newline | Tab | Quote | Backslash | Decimal;
terminal StrCon: '\"' StrChar* '\"';

//symbol
terminal SymbolCon: "'" SymbolChar*;
fragment SymbolChar: ~( '\u0000'..'\u001F' | ' ' | ';' | ',' | '>' | '}' | ')');


// whitespaces and comments
fragment ML_COMMENT: '/*' (~'*' | '*' ~'/')* '*/';
fragment SL_COMMENT: '//' ~('\n'|'\r')*;
hidden terminal WS: (' '|'\t'|'\r'|'\n'|SL_COMMENT|ML_COMMENT)+;
