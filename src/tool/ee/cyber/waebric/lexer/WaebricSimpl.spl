grammar ee.cyber.waebric.lexer.WaebricSimpl;

options (backtrack=true;)

scalaheader {
// import HelperMethods._
}

Program: 'module' IdCon Definitions;

Definitions: Definition+;

option Definition: FunctionDef | Site | Import;

FunctionDef:
    "def" IdCon ("(" arguments=Formals? ")")?
	    statements=Statement*
    "end";
Formals: left=IdCon ("," rest=IdCon)*;


Import: "import" module=ModuleId;
ModuleId: first=IdCon ("." rest=IdCon)*;

// File Mapping Nodes
Site:
    "site"
        mappings=Mappings? 
    "end";
Mappings: first=Mapping (";" rest=Mapping)*;
Mapping: path=Path ":" markup=Markup;

// File mapping terminals
// fragment PathElement: (Letter|Digit|'%')+; //|~('\\'|'/')
// fragment FileExt: (Letter|Digit)+;
// fragment FileName: PathElement "." FileExt;
// terminal Path: ("/")? (PathElement "/")* FileName;

terminal Path: ( PathElement '/' )* PathElement '.' FileExt; 
fragment PathElement:( Letter | Digit | '%' )+ ; // '!'..'+' causes java heap exception
fragment FileExt:( Letter | Digit )+ ;




// General
fragment Letter: ('a'..'z'|'A'..'Z');
fragment Digit: ('0'..'9');
fragment Hexadecimal: (Letter | Digit)+;
terminal IdCon: Letter (Letter|Digit|'-')*;
terminal NatCon: Digit+;

Markup: Designator Arguments?;  // cons(call)
Designator: IdCon Attribute*;
Arguments: "(" (first=Argument ("," rest=Argument)*)? ")";
option Argument: AttrArg | Expression;

AttrArg: IdCon "=" Expression;

option Attribute:
    IdAttr
    | ClassAttr
    | NameAttr 
    | TypeAttr 
    | WidthHeightAttr 
    | HeightAttr;

IdAttr: "#" id=IdCon;
ClassAttr: "." cl=IdCon;
NameAttr: '$' name=IdCon;
TypeAttr: ":" t=IdCon;
WidthHeightAttr: "@" width=NatCon "%" height=NatCon;
HeightAttr: "@" height=NatCon;

Expression: CatExpression | ListExpression | RecordExpression;

CatExpression: left=FieldExpression ("+" right=Expression)?;
FieldExpression: PrimitiveExpression ("." IdCon)?;
option PrimitiveExpression:
     IdCon
     | SymbolCon
     | NatCon 
     | Text;


ListExpression: "[" (first=Expression ("," rest=Expression)*)? "]";
RecordExpression: "{" (first=KeyValuePair ("," rest=KeyValuePair)*)? "}";
KeyValuePair: IdCon ":" Expression;


Statement: 
    IfStatement
    | EachStatement
    | LetStatement
    | BlockStatement
    // | CommentStatement
    | EchoStatement
    | CdataStatement
    | YieldStatement
    | MarkupStatement;

// TODO: rule for if without else.
IfStatement: "if" "(" Predicate ")" ifStat=Statement "else" elseStat=Statement;
EachStatement: "each" "(" IdCon ":" Expression ")" Statement;  

LetStatement: "let" Assignment+ "in" Statement* "end";
Assignment: VarBinding | FuncBinding;
VarBinding: IdCon "=" Expression ";";
FuncBinding: func=IdCon "(" (first=IdCon ("," rest=IdCon)*)? ")" "=" Statement;

BlockStatement: "{" Statement* "}";
// CommentStatement: "comment" StrCon ";";
EchoStatement: "echo" (Expression|Embedding) ";";
CdataStatement: "cdata" Expression ";"; 
YieldStatement: "yield" ";";
MarkupStatement: Markup MarkupChain;

Predicate: left=PrimPredicate (op=PredicateOp rest=PrimPredicate)*;
terminal PredicateOp: AndOp | OrOp;
fragment AndOp: "&&";
fragment OrOp: "||";
option PrimPredicate:
    NotPredicate
    | IsAPredicate;

NotPredicate: "!" PrimPredicate;
// TODO: just Expression should be converted to ExprPredicate or something.
IsAPredicate: Expression ("." PredType "?")?;
PredType: "list" | "record" | "string";


MarkupChain: ";" | Expression ";" | Embedding ";" | Statement;

Embedding: PreText Embed TextTail;

Embed: Markup* Expression | Markup+;

TextTail: PostText | MidText Embed TextTail;


//symbol
terminal SymbolCon: "'" SymbolChar*;
fragment SymbolChar: ~( '\u0000'..'\u001F' | ' ' | ';' | ',' | '>' | '}' | ')');

//Text and TextChar related
fragment TextChar:~('\u0000'..'\u001F' | '&' | '"' | '<' | '\u0080'..'\uFFFF' ) |
 '\n' | '\r' | '\t' | EscQuote | Amp | CharRef | EntRef ;
fragment EscQuote:'\\\\' | '\\"';
fragment Amp:'\&' ~('#' | '0'..'9' | 'a'..'z' | 'A'..'Z' | '_' | ':')+;
fragment CharRef:'&#' Digit+ ';' | '&#x' Hexadecimal ';' ;
fragment EntRef:'&' ( Letter | '_' | ':' ) ( Letter | Digit | '.' | '-' | '_' | ':')* ';' ;
terminal Text: '"' TextChar* '"';

terminal PreText: '"' TextChar* '<';
terminal PostText: '>' TextChar* '"';
terminal MidText: '>' TextChar* '<';

//StrCon and StrChar
//As this will be processed after Text, all patterns that match
//both, were already considered as Text. "comment" tag only
//uses StrCon and this must be considered.

// fragment Newline: '\\n';
// fragment Tab: '\\t';
// fragment Quote: '\\"';
// fragment Backslash: '\\\\';
// fragment Decimal: '\\\\' 'a:' Digit 'b:' Digit 'c:' Digit;
// fragment StrChar: ~('\u0000'..'\u001F' | '"' | '\\') | Newline | Tab | Quote | Backslash | Decimal;
// terminal StrCon: '"' StrChar* '"';




// Unchecked stuff below.

/*

RecordPair: pairName=IdCon ":" pairValue=PrimitiveData;
RecordItems: recArg=RecordPair ("," recRest=RecordItems)?;
DataList: "[" list=DataListItems "]";
ArgumentsExp: arg=Expression ("," rst=Arguments)?;
ArgumentsIdCon: id=IdCon "=" Expression;
option Arguments: ArgumentsExp | ArgumentsIdCon;

// primitive
DataNum: numVal=NatCon;
DataSymbol: symVal=SymbolCon;

// with type check as well
DataStr: strVal=Text;
DataRecords: "{" records=RecordItems "}";
DataListItems: listArg=PrimitiveData ("," listRest=DataListItems)?;


Statement: IdCon;

// Expressions
option PrimitiveData: DataNum | DataStr | DataSymbol;
option Expression: PrimitiveData | DataList | DataRecords;

//Field: Expression "." IdCon;

Field
	returns Expression {FieldExpression(left, field)}
	: left=Expression "." field=IdCon;
Cat
	returns Expression {makeCat(left :: rest)}
    : left=Expression ("+" rest=Expression)*;


//Predicates
option Predicate: TypeCheck | Not;

TypeCheck returns Predicate {TypeCheckPredicate(exp, t)}: exp=Expression "." t=Types "?";
Not returns Predicate {NotPredicate(p)}: "!" p=Predicate;
Or returns Predicate {getAndOrPredicate(new String("or"), left :: rest)}
    : left=And ("||" rest=And)*;
And returns Predicate {getAndOrPredicate(new String("and"), left :: rest)}
    : left=Predicate ("&&" rest=Predicate)*;

// Types
option Types {
    def text: String
}:
	TypeList |
	TypeString |
	TypeRecord;


// Embedding and Markup
TextTailPost: post=PostText;

TextTailMid: mid=MidText embed=Embed tail=TextTail;
option TextTail: TextTailPost | TextTailMid;

Embedding: pre=PreText embed=Embed tail=TextTail;
ExpEmbed: markuplist=Markup* exp=Expression;
MarkupEmbed: makrkuplist=Markup markup=Markup;
option Embed: ExpEmbed | MarkupEmbed;

Markup: design=Designator? args=Arguments;
Designator: id=IdCon attrs=Attribute*;

IdAttr: "#" id=IdCon;
ClassAttr: "." cl=IdCon;

NameAttr: '$' name=IdCon;
TypeAttr: ":" t=IdCon;
WidthHeightAttr: "@" width=NatCon "%" height=NatCon;
HeightAttr: "@" height=NatCon;
option Attribute:
	IdAttr |
	ClassAttr |
	NameAttr |
	TypeAttr |
	WidthHeightAttr |
	HeightAttr;
/*
Statement: (mlist=Markup+ Statement) |
	(m=Markup ";") |
	(mlist=Markup+ m=Markup ";") |
	(mlist=Markup+ exp=Expression ";") |
	(mlist=Markup+ emb=Embedding ";") |
	(d=Designator);
	*/
//**** TERMINALS **** //
// Note that the terminals are matched according to the order of definition
// therefore some general terminals are used for multiple places

terminal TypeRecord: 'record';
terminal TypeList: 'list';
terminal TypeString: 'string';



//Text and TextChar related
fragment TextChar:	~('\u0000'..'\u001F' | '&' | '"' | '<' | '\u0080'..'\uFFFF' ) |
			 '\n' | '\r' | '\t' | EscQuote | Amp | CharRef | EntRef ;
fragment EscQuote:	'\\\\' | '\\"';
fragment Amp:		'\&' ~('#' | '0'..'9' | 'a'..'z' | 'A'..'Z' | '_' | ':')+;
fragment CharRef:	'&#' Digit+ ';' | '&#x' Hexadecimal ';' ;
fragment EntRef:	'&' ( Letter | '_' | ':' ) ( Letter | Digit | '.' | '-' | '_' | ':')* ';' ;
terminal Text: '\"' TextChar* '\"';

terminal PreText: '"' TextChar* '<';
terminal PostText: '>' TextChar* '\"';
terminal MidText: '>' TextChar* '<';


//StrCon and StrChar
//As this will be processed after Text, all patterns that match
//both, were already considered as Text. "comment" tag only
//uses StrCon and this must be considered.

fragment Newline: '\\n';
fragment Tab: '\\t';
fragment Quote: '\\"';
fragment Backslash: '\\\\';
fragment Decimal: '\\\\' 'a:' Digit 'b:' Digit 'c:' Digit;
fragment StrChar: ~('\u0000'..'\u001F' | '"' | '\\') | Newline | Tab | Quote | Backslash | Decimal;
terminal StrCon: '\"' StrChar* '\"';



*/

// whitespaces and comments
fragment ML_COMMENT: '/*' (~'*' | '*' ~'/')* '*/';
fragment SL_COMMENT: '//' ~('\n'|'\r')*;
hidden terminal WS: (' '|'\t'|'\r'|'\n'|SL_COMMENT|ML_COMMENT)+;
